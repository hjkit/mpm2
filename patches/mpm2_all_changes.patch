diff --git a/include/mpm_cpu.h b/include/mpm_cpu.h
index dcb3869..b3e476e 100644
--- a/include/mpm_cpu.h
+++ b/include/mpm_cpu.h
@@ -35,23 +35,17 @@ public:
     void port_out(qkz80_uint8 port, qkz80_uint8 value) override;
     qkz80_uint8 port_in(qkz80_uint8 port) override;
 
-    // Override halt - for proper shutdown handling
-    void halt(void) override;
-
     // Override execute for instruction tracing
     void execute(void) override;
 
     // Override unimplemented opcode - for better diagnostics
     void unimplemented_opcode(qkz80_uint8 opcode, qkz80_uint16 pc) override;
 
-    // Check if CPU is halted
-    bool is_halted() const { return halted_; }
-    void clear_halted() { halted_ = false; }
+    // is_halted(), clear_halted(), set_halted() are now in base class qkz80
 
 private:
     XIOS* xios_ = nullptr;
     BankedMemory* banked_mem_ = nullptr;
-    bool halted_ = false;
     uint8_t last_xios_result_ = 0;  // Result from last XIOS dispatch (for IN instruction)
 
     // Handle XIOS dispatch via port 0xE0
diff --git a/src/mpm_cpu.cpp b/src/mpm_cpu.cpp
index 3634c56..7fe7edb 100644
--- a/src/mpm_cpu.cpp
+++ b/src/mpm_cpu.cpp
@@ -90,11 +90,7 @@ void MpmCpu::handle_bank_select(uint8_t bank) {
     }
 }
 
-void MpmCpu::halt(void) {
-    // Z80 HALT instruction - CPU waits for interrupt
-    // In MP/M II context, this is the normal idle loop
-    halted_ = true;
-}
+// halt() is now handled by base class qkz80::halt()
 
 void MpmCpu::execute(void) {
     // Debug disabled for cleaner boot output
@@ -122,5 +118,5 @@ void MpmCpu::unimplemented_opcode(qkz80_uint8 opcode, qkz80_uint16 pc) {
     }
     std::cerr << std::dec << std::endl;
 
-    halted_ = true;
+    set_halted();
 }
diff --git a/src/ssh_session_libssh.cpp b/src/ssh_session_libssh.cpp
index 7ec98af..f178cff 100644
--- a/src/ssh_session_libssh.cpp
+++ b/src/ssh_session_libssh.cpp
@@ -213,10 +213,13 @@ bool SSHSession::poll_io() {
     char buf[256];
     int n = ssh_channel_read_nonblocking(channel_, buf, sizeof(buf), 0);
     if (n > 0) {
+        std::cerr << "[SSH] Console " << console_id_ << " received " << n << " bytes: ";
         for (int i = 0; i < n; i++) {
             uint8_t ch = static_cast<uint8_t>(buf[i]);
+            std::cerr << std::hex << (int)ch << " ";
             con->input_queue().try_write(ch);
         }
+        std::cerr << std::dec << "\n";
     } else if (n == SSH_ERROR) {
         state_ = SSHState::CLOSED;
         return false;
@@ -235,8 +238,6 @@ bool SSHSession::poll_io() {
             state_ = SSHState::CLOSED;
             return false;
         }
-        // If not all bytes written, we'd need to buffer - for now just continue
-        // The queue will refill and we'll write more next poll
     }
 
     return true;
diff --git a/src/xios.cpp b/src/xios.cpp
index 2992b6b..53a2886 100644
--- a/src/xios.cpp
+++ b/src/xios.cpp
@@ -221,11 +221,15 @@ void XIOS::do_polldevice() {
     }
 
     int console = device / 2;
-    bool is_input = (device & 1) != 0; 
+    bool is_input = (device & 1) != 0;
 
     Console* con = ConsoleManager::instance().get(console);
     if (is_input) {
+      size_t avail = con ? con->input_queue().available() : 0;
       uint8_t status = con ? con->const_status() : 0;
+      if (avail > 0) {
+	std::cerr << "[POLLDEV] Console " << console << " input: avail=" << avail << " status=" << (int)status << "\n";
+      }
       if (status) {
 	result = 0xFF;
       }
diff --git a/src/z80_runner.cpp b/src/z80_runner.cpp
index 8b1f094..854e8a2 100644
--- a/src/z80_runner.cpp
+++ b/src/z80_runner.cpp
@@ -138,11 +138,8 @@ bool Z80Runner::run_polled() {
             }
         }
 
-	if (cpu_->check_interrupts()) {
-	  cpu_->clear_halted();
-	}
-        cpu_->execute();
-        instruction_count_++;
+	cpu_->execute();
+	instruction_count_++;
     }
 
     return true;
