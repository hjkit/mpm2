Move Z80 halt/interrupt handling to core qkz80 CPU emulation

--- a/cpmemu/src/qkz80.h
+++ b/cpmemu/src/qkz80.h
@@ -48,6 +48,7 @@ class qkz80 {
   qkz80_uint8 int_vector; // Vector for IM0/IM2 (ignored in IM1)
   bool ei_delay;          // EI delay: Z80 executes one more instruction after EI
+  bool halted_;           // CPU is halted (waiting for interrupt)

   // Constructor takes a memory object pointer
   qkz80(qkz80_cpu_mem *memory);
@@ -87,6 +88,10 @@ class qkz80 {
   // HALT instruction - override in subclass to customize behavior
   virtual void halt(void);

+  // Check if CPU is halted (waiting for interrupt)
+  bool is_halted() const { return halted_; }
+  void clear_halted() { halted_ = false; }
+  void set_halted() { halted_ = true; }

--- a/cpmemu/src/qkz80.cc
+++ b/cpmemu/src/qkz80.cc
@@ -5,7 +5,8 @@ qkz80::qkz80(qkz80_cpu_mem *memory):
   int_pending(false),
   nmi_pending(false),
   int_vector(0xFF),
-  ei_delay(false) {
+  ei_delay(false),
+  halted_(false) {
   regs.cpu_mode = qkz80_reg_set::MODE_Z80;
 }

 void qkz80::halt(void) {
-  // Empty - override in subclass to handle halt
+  halted_ = true;
 }

+void qkz80::execute(void) {
+  // Check and handle pending interrupts before executing instruction
+  if (check_interrupts()) {
+    clear_halted();
+  }
+  ...

--- a/include/mpm_cpu.h (remove duplicate halted_ field)
+++ b/include/mpm_cpu.h
-    // Check if CPU is halted
-    bool is_halted() const { return halted_; }
-    void clear_halted() { halted_ = false; }
+    // is_halted(), clear_halted(), set_halted() are now in base class qkz80

 private:
     XIOS* xios_ = nullptr;
     BankedMemory* banked_mem_ = nullptr;
-    bool halted_ = false;
